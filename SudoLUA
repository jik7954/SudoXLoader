-- omg skid?
local Byte         = string.byte; local Char         = string.char; local Sub          = string.sub; local Concat       = table.concat; local LDExp        = math.ldexp; local GetFEnv      = getfenv or function() return _ENV end; local Setmetatable = setmetatable; local Select       = select;  local Unpack = unpack; local ToNumber = tonumber;local function decompress(b)local c,d,e="","",{}local f=256;local g={}for h=0,f-1 do g[h]=Char(h)end;local i=1;local function k()local l=ToNumber(Sub(b, i,i),36)i=i+1;local m=ToNumber(Sub(b, i,i+l-1),36)i=i+l;return m end;c=Char(k())e[1]=c;while i<#b do local n=k()if g[n]then d=g[n]else d=c..Sub(c, 1,1)end;g[f]=c..Sub(d, 1,1)e[#e+1],c,f=d,d,f+1 end;return table.concat(e)end;local ByteString=decompress('23W26E2751J26M1M1P1E26M2751N26U2791D26U2751M26M25Y26E1D27C26E1325I27G25I2751A27U27N27X1B25Y27G27M26E1A2831D28328527I28727521F26627G26627521J24M27G24M27521I24U23A26E21A24U27521N28J1P1R28L26E21M25221Y27N25227521Q27527N2971Z25A27G25A27521323Q27G23Q27521725Q27G25Q2751W27S1P1D27U22U22A29426E21B29W22E24E27521B2A126E22A26U27U21727I26E21Q2A126F152A421Q22U1M26E1522U29O21A1P1P1M2AO2491Z23Y27921G23Y29E29L1P21G29N26E2162831C28321B2B02B227521026M1K1P21L26M26C22U22E22U2942122AM26E22E2321626E1K2322752BR2941D2BW26E22I28Y1D28Y22M28G27N2C821U28S27N2CC21Y2862832222BP1D2BP2262CJ2BP21U25I27U29S27521U25A24M26F1D29D26E21Y2CC21B2CC22229I26E1X2D62262C12C02752362DB2C121Y2CQ27Y27521Y25A2522CX2CZ22629227N2DR2362262751D2DV26E22722M27G22M2752262E327N2E62E528A2E623B2BA2B323F29B2B12CZ21P26M24626F1B27C22U1G29721K2752EP24E27921K2A122U2EJ22U2EM2EO2EQ2752ES26E2EP29G1P21K29I22U23I2E127Q2E622Q2122AJ1321227523H26M21226F2182F326E2EW2ET23E21I23A26F21021I2ET22M22E26F1O2E622U1E2AJ1U1E27522Y2122FQ1D2FM26E22Y1M2AJ1D2AJ26E23A21A2GN21A2DD2GP2GO2E42GD27N2GZ1G23Q2AP1D2H324922526M2F121R2FT2F52ET2EQ2FV2F72262GJ21B2GJ2EJ2EL2EN2F72F426E2F62EP24U2EW28S2FD2FF132E62EJ2G52HO2EP2ER2HE2FU2FA2FW2FY2G02G226E22Q2G42G62FH162AJ1Y2BT2GQ2GS26E172GU26E2262IL21B2IL1G23A2AP21K2IX24922M2IC21B2IC21U29629X2J72162971T2971G1U26H2HR1U1P2J125A25Y26F182CZ21E23A2JM1D28P26E210161R2AQ2JX2491U28Y21B28Y122D22CC122JB2JD2JF2JH2JJ1M2722A827227J26M2941A27P27K29I27O2751I2A727N2AA1I26M28A27P2KW2DW27P2JG27526F26K29723U23T23R23M24524224423Z23S23L26F26A29723L23R23V23N2L529724H23N24224P23O23W23N23P24224526F26P2971W22N26621N1P23724822N24I21J23S24J24E23721Y21T23V22H1W21U25J24U24A26D2972971M26126F26829725123T24324423P2LO2MS2MW2972LC2LE2LG26F2MR27524524323O2LI29723P23Y23R2442NC2MS2752NN2751623T2CW27329722A21P24M22I22Y1027121725N22B24Y23W24X21W23823B25522Y1N23826Q24924V26123O2NQ27526724M2OM27528Y297'); 			 local BitXOR = bit and bit.bxor or function(a,b)     local p,c=1,0     while a>0 and b>0 do         local ra,rb=a%2,b%2         if ra~=rb then c=c+p end         a,b,p=(a-ra)/2,(b-rb)/2,p*2     end     if a<b then a=b end     while a>0 do         local ra=a%2         if ra>0 then c=c+p end         a,p=(a-ra)/2,p*2     end     return c end  local function gBit(Bit, Start, End) 	if End then 		local Res = (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);  		return Res - Res % 1; 	else 		local Plc = 2 ^ (Start - 1);          return (Bit % (Plc + Plc) >= Plc) and 1 or 0; 	end; end;  local Pos = 1;  local function gBits32()     local W, X, Y, Z = Byte(ByteString, Pos, Pos + 3);  	W = BitXOR(W, 230) 	X = BitXOR(X, 230) 	Y = BitXOR(Y, 230) 	Z = BitXOR(Z, 230)      Pos	= Pos + 4;     return (Z*16777216) + (Y*65536) + (X*256) + W; end;  local function gBits8()     local F = BitXOR(Byte(ByteString, Pos, Pos), 230);     Pos = Pos + 1;     return F; end;  local function gFloat() 	local Left = gBits32(); 	local Right = gBits32(); 	local IsNormal = 1; 	local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32)) 					+ Left; 	local Exponent = gBit(Right, 21, 31); 	local Sign = ((-1) ^ gBit(Right, 32)); 	if (Exponent == 0) then 		if (Mantissa == 0) then 			return Sign * 0; 		else 			Exponent = 1; 			IsNormal = 0; 		end; 	elseif (Exponent == 2047) then         return (Mantissa == 0) and (Sign * (1 / 0)) or (Sign * (0 / 0)); 	end; 	return LDExp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52))); end;  local gSizet = gBits32; local function gString(Len)     local Str;     if (not Len) then         Len = gSizet();         if (Len == 0) then             return '';         end;     end;      Str	= Sub(ByteString, Pos, Pos + Len - 1);     Pos = Pos + Len;  	local FStr = {} 	for Idx = 1, #Str do 		FStr[Idx] = Char(BitXOR(Byte(Sub(Str, Idx, Idx)), 230)) 	end      return Concat(FStr); end;  local gInt = gBits32; local function _R(...) return {...}, Select('#', ...) end  local function Deserialize()     local Instrs = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };     local Functions = {  }; 	local Lines = {};     local Chunk =  	{ 		Instrs, 		nil, 		Functions, 		nil, 		Lines 	};for Idx=1,gBits32() do  									local Data1=BitXOR(gBits32(),244); 									local Data2=BitXOR(gBits32(),235);   									local Type=gBit(Data1,1,2); 									local Opco=gBit(Data2,1,11); 									 									local Inst= 									{ 										Opco, 										gBit(Data1,3,11), 										nil, 										nil, 										Data2 									};  									if (Type == 0) then Inst[3]=gBit(Data1,12,20);Inst[5]=gBit(Data1,21,29); 									elseif(Type==1) then Inst[3]=gBit(Data2,12,33); 									elseif(Type==2) then Inst[3]=gBit(Data2,12,32)-1048575; 									elseif(Type==3) then Inst[3]=gBit(Data2,12,32)-1048575;Inst[5]=gBit(Data1,21,29); 									end; 									 									Instrs[Idx]=Inst;end; 								local ConstCount = gBits32()     							local Consts = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  								for Idx=1,ConstCount do  									local Type=gBits8(); 									local Cons; 	 									if(Type==0) then Cons=(gBits8() ~= 0); 									elseif(Type==3) then Cons = gFloat(); 									elseif(Type==1) then Cons=gString(); 									end; 									 									Consts[Idx]=Cons; 								end; 								Chunk[2] = Consts 								for Idx=1,gBits32() do Functions[Idx-1]=Deserialize();end;Chunk[4] = gBits8();return Chunk;end; local function Wrap(Chunk, Upvalues, Env) 	local Instr  = Chunk[1]; 	local Const  = Chunk[2]; 	local Proto  = Chunk[3]; 	local Params = Chunk[4];  	return function(...) 		local Instr  = Instr;  		local Const  = Const;  		local Proto  = Proto;  		local Params = Params;  		local _R = _R 		local InstrPoint = 1; 		local Top = -1;  		local Vararg = {}; 		local Args	= {...};  		local PCount = Select('#', ...) - 1;  		local Lupvals	= {}; 		local Stk		= {};  		for Idx = 0, PCount do 			if (Idx >= Params) then 				Vararg[Idx - Params] = Args[Idx + 1]; 			else 				Stk[Idx] = Args[Idx + 1]; 			end; 		end;  		local Varargsz = PCount - Params + 1  		local Inst; 		local Enum;	  		while true do 			Inst		= Instr[InstrPoint]; 			Enum		= Inst[1];if Enum <= 29 then if Enum <= 14 then if Enum <= 6 then if Enum <= 2 then if Enum <= 0 then local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K; elseif Enum == 1 then Stk[Inst[2]]=#Stk[Inst[3]];else Stk[Inst[2]]=Env[Const[Inst[3]]];end; elseif Enum <= 4 then if Enum > 3 then Stk[Inst[2]]();Top=A;else local B;local A;Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Const[Inst[3]]];end; elseif Enum > 5 then if(Const[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];end; elseif Enum <= 10 then if Enum <= 8 then if Enum > 7 then Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[5]];else local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]();Top=A;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];do return end;end; elseif Enum > 9 then Stk[Inst[2]]=Stk[Inst[3]]*Const[Inst[5]];else Stk[Inst[2]]=Stk[Inst[3]]-Const[Inst[5]];end; elseif Enum <= 12 then if Enum == 11 then Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[5]];else Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[5]];end; elseif Enum == 13 then Stk[Inst[2]]=Stk[Inst[3]]%Const[Inst[5]];else Stk[Inst[2]]=Stk[Inst[3]]%Const[Inst[5]];end; elseif Enum <= 21 then if Enum <= 17 then if Enum <= 15 then if(Const[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end; elseif Enum == 16 then Top=Inst[2];else Stk[Inst[2]]=#Stk[Inst[3]];end; elseif Enum <= 19 then if Enum > 18 then Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]*Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=InstrPoint+Inst[3];else Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];end; elseif Enum == 20 then Stk[Inst[2]]=Stk[Inst[3]];else Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[5]];end; elseif Enum <= 25 then if Enum <= 23 then if Enum > 22 then Stk[Inst[2]]={};else local A;Stk[Inst[2]]=Env[Const[Inst[3]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Const[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Stk[A]=Stk[A]-Stk[A+2];InstrPoint=InstrPoint+Inst[3];end; elseif Enum == 24 then do return end;else local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]=Stk[Inst[3]]%Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]+Const[Inst[5]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];end; elseif Enum <= 27 then if Enum == 26 then Stk[Inst[2]]=Stk[Inst[3]]+Const[Inst[5]];else local A=Inst[2];local Step=Stk[A+2];local Index=Stk[A]+Step;Stk[A]=Index;if Step>0 then if Index<=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;elseif Index>=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;end; elseif Enum == 28 then Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];else local A=Inst[2];local Step=Stk[A+2];local Index=Stk[A]+Step;Stk[A]=Index;if Step>0 then if Index<=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;elseif Index>=Stk[A+1] then InstrPoint=InstrPoint+Inst[3];Stk[A+3]=Index;end;end; elseif Enum <= 44 then if Enum <= 36 then if Enum <= 32 then if Enum <= 30 then Stk[Inst[2]]=Stk[Inst[3]]*Const[Inst[5]]; elseif Enum > 31 then if(Stk[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else do return end;end; elseif Enum <= 34 then if Enum > 33 then Stk[Inst[2]]=Stk[Inst[3]];else if(Stk[Inst[2]]~=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum == 35 then Stk[Inst[2]]=Stk[Inst[3]][Const[Inst[5]]];else Stk[Inst[2]]={};end; elseif Enum <= 40 then if Enum <= 38 then if Enum > 37 then local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;else local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum > 39 then local A=Inst[2];local Args={};local Edx=0;local Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;local Results={Stk[A](Unpack(Args,1,Limit-A))};local Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;else Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];end; elseif Enum <= 42 then if Enum > 41 then Stk[Inst[2]]=Env[Const[Inst[3]]];else Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[5]];end; elseif Enum > 43 then local Results;local Limit;local Edx;local Args;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];A=Inst[2];Args={};Edx=0;Limit=A+Inst[3]-1;for Idx=A+1,Limit do Edx=Edx+1;Args[Edx]=Stk[Idx];end;Results={Stk[A](Unpack(Args,1,Limit-A))};Limit=A+Inst[5]-2;Edx=0;for Idx=A,Limit do Edx=Edx+1;Stk[Idx]=Results[Edx];end;Top=Limit;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[5]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];else Stk[Inst[2]]=Stk[Inst[3]]-Const[Inst[5]];end; elseif Enum <= 51 then if Enum <= 47 then if Enum <= 45 then InstrPoint=InstrPoint+Inst[3]; elseif Enum == 46 then Stk[Inst[2]]=Stk[Inst[3]]+Const[Inst[5]];else Stk[Inst[2]]=Stk[Inst[3]]/Const[Inst[5]];end; elseif Enum <= 49 then if Enum > 48 then if(Stk[Inst[2]]~=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;else local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Const[Inst[5]]];end; elseif Enum > 50 then Top=Inst[2];else if(Stk[Inst[2]]>=Stk[Inst[5]])then InstrPoint=InstrPoint+1;else InstrPoint=InstrPoint+Inst[3];end;end; elseif Enum <= 55 then if Enum <= 53 then if Enum == 52 then local A=Inst[2];Stk[A]=Stk[A]-Stk[A+2];InstrPoint=InstrPoint+Inst[3];else InstrPoint=InstrPoint+Inst[3];end; elseif Enum == 54 then Stk[Inst[2]]=Const[Inst[3]];else local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[5] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;end; elseif Enum <= 57 then if Enum > 56 then Stk[Inst[2]]=Const[Inst[3]];else Stk[Inst[2]]();Top=A;end; elseif Enum > 58 then local A=Inst[2];Stk[A]=Stk[A]-Stk[A+2];InstrPoint=InstrPoint+Inst[3];else Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[5]];end; 			InstrPoint	= InstrPoint + 1; 		end;     end; end;	 return Wrap(Deserialize(), {}, GetFEnv())(); 
